---
title: "1. bikedata"
author: 
  - "Mark Padgham"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        theme: flatly
vignette: >
  %\VignetteIndexEntry{1. osmdata}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 1. Introduction

`bikedata` is an R package for downloading and aggregating data from public
bicycle hire systems. Cities and names of associated public bicycle Systems
currently included, along with numbers of bikes and of docking stations, are:

1. London, U.K. Barclay's Bicycle Hire
2. New York City NY, U.S.A.citibike
3. Boston CT U.S.A. Hubway
4. Chicago MW U.S.A. Divvy
5. Washingon DC  U.S.A.Capital BikeShare
6. Los Angeles CA U.S.A.Metro

Note that access to data from the Barclay's Bicycle Hire system of London,
U.K. requires an initial registraion in order to obtain an `OAuth` key to
access the data.

Cities with bike systems which do not currently provide data, but are likely to
in the future and for which `bikedata` will be adapted as soon as data become
available include:

1. Miami, Florida
2. Portland, Oregon

Cities with extensively developed systems and cultures of public hire bicycles,
yet which do not provide (publically available) data include:

1. Shenzhen, China
2. Barcelona, Spain
3. Paris, France

The development version of the `bikedata` R package can be installed with the
`devtools` package using the following command:
```{r install, eval=FALSE}
devtools::install_github('mpadge/bikedata')
```

```{r, echo=FALSE, message=FALSE, results='hide'}
devtools::load_all('..', export_all = FALSE)
```

Once installed, it can be loaded in the usual way:

```{r}
library(bikedata)
```

## 2. Main Functions

All of the public bicycle hire systems in the first of the above lists record
and disseminate invidual trip data, minimally including the times and places at
which every trip starts and ends. Some systems provide additional anonymised
individual data, typically including whether or not a user is registered with
the system and if so, addtional data including age, gender, and residential
postal code.

These data on individual trips can be imported into `R` with the primary function
 `store_bikedata()`, whcih minimally requires specifying a city from the above
 list and the name of a database in which the data will be stored.
```{r, eval=FALSE}`
store_bikedata (bikedb = 'bikedb', city = 'la')
```
This function call will download all available data from the nominated hire
bicycle system (in this case, the Metro system of Los Angeles, CA) and store it
in an `SQLite3` database. The function returns the number of trips added to the
database. By default, both the downloaded data and the `SQLite3` database are
stored in the temporary directory of the current `R` session. The downloaded
data are deleted after having been loaded into the `SQLite3` database.  (All of
these options may be overrudden as described below.)

Successive calls to `store_bikedata()` will append additional data to the same
database. For example,
```{r}, eval=FALSE`
store_bikedata (bikedb = "bikedb", city = 'divvy', dates = 2017)
```
will append all data from Chicago's Divvy bike system from the year 2017 to the
database created with the first call above. The function again returns the
number of trips *added* to the database, which is now less than the total
number of trips stored of:
```{r, eval=FALSE}
bike_total_trips (bikedb = 'bikedb')
```
For consistency and to avoid potential confusion of function names, most
functions in the `bikedata` package begin with `bike_`.

Finally, an ''origin-desination'' matrix of numbers of trips between all pairs
of stations can be aggregated with the call, 
```{r, eval=FALSE}
tm <- bike_tripmat (bikedb = "bikedb")
```
Which produces a message suggesting nominating a city for which to extract a
`bike_tripmat`. Without nominating a city,
```{r, eval=FALSE}
dim (tm)
length (which (is.na (tm))) / length (tm)
```
over half of the returned matrix is empty, because of course there can be no
trips between different cities or bike systems. Nominating a particular city
gives equivalent values of,
```{r, eval=FALSE}
tm <- bike_tripmat (bikedb = 'bikedb', city = 'la')
dim (tm); length (which (is.na (tm))) / length (tm)
tm <- bike_tripmat (bikedb = 'bikedb', city = 'ch')
dim (tm); length (which (is.na (tm))) / length (tm)
```

Details of the docking stations associated with these trip matrices can be
obtained with
```{r, eval=FALSE}
bike_stations (bikedb = "bikedb")
bike_stations (bikedb = "bikedb", city = 'la')
```

The remainder of this vignette details these three distinct functional aspects
- downloading, storage, and extraction of data.

## 3. Downloading Data

The `dl_bikedata()` function neither establishes nor connects to the database
described above - it merely downloads the nominated data to the (optionally)
nominated location. The function accepts only one additional argument (`dates`)
specifying ranges of dates for which data should be downloaded. The format of
the `dates` argument is quite flexible so that,
```{r, eval=FALSE}
dl_bikedata (city = 'dc', dates = c('2015.11', '2015.12', 'Jan 2016'))
```
will download data for all 12 months of the year 2016, while,
```{r, eval=FALSE}
dl_bikedata (city = 'ny', dates=201604:201608))
```
will download data from April to August (inclusively) for that year. Dates can
also be entered as character strings, with the following calls producing
results equivalent to the preceding call, 
```{r, eval=FALSE}
dl_bikedata (city = 'ny', dates="2016/04:2016/08"))
dl_bikedata (city = 'new york', dates="201604:201608"))
dl_bikedata (city = 'n.y.c.', dates="2016-04:2016-08"))
dl_bikedata (city = 'new', dates=c (201604, 201605, 201606, 201607, 201608))
dl_bikedata (city = 'ci', dates=201600 + 4:8)
```
The arguments `city = 'new'` and `city = 'ci'` in the final call are sufficient
to uniquely identify New York City's citibike system.

As mentioned, data from the Barclay's Bicycle Hire Scheme of London, U.K.
require registration with [Transport for London](tfl.gov.uk). Registration
enables access to an `OAuth` key which must additionally be passed to both the
`dl_bikedata()` and `store_bikedta()` functions to access these data.
```{r}
store_bikedata (city = 'lo', bikedb = 'bikedb')
```
If files have been previously downloaded to a nominated directory, then calling
the `dl_bikedata()` function will only download those data files that do not
already exist. This function may thus be used to periodically refresh the
contents of a nominated directory as new data files become available.

## 4. Storing Data

As mentioned above, individual trip data are stored in a single `SQLite3`
database, created by default in the temporary directory of the current `R`
session.. Specifying a path for the `bikedb` argument in the `store_bikedata()`
function will create a database that will remain in that location until
explicitly deleted. 

The nominated database is created if it does not already exist, otherwise
additional data are appended to the existing database. As for the
`dl_bikedata()` function demonstrated above, a `dates` argument can also be
passed to `store_bikedata()` to download data within a defined range of dates.

`bikedata` is explicity designed *not* to permit automatic downloading of all
data in a single call, lest an innocent exploratory usage inadvertendly
generate a database 5GB in size.  Loading data from other cities accordingly
requires repeated calls to `store_bikedata()`. The entirety of currently
avaialable data can be loaded with the following lines:
```{r}
for (ci in bike_available_cities ())
    ntrips <- store_bikedata (city = ci, bikedb = 'bikedb')
```
Although the `bikedata` package aims to circumvent any need to access the
database directly, through providing ready extraction of trip data for most
analytical needs, direct access may be achieved either using the convenient
`dplyr` functions, or the more powerful functionality provided by the `RSQLite`
package.

### 4.1 Database Indexes

The `store_bikedata()` function also has a defult option to create indexes for
more efficient data extraction. Indexes are always created for cities, with the
`create_index = TRUE` option creating additional indexes for dates and times.
Setting this parameter to `FALSE` will enable faster initial storage of data,
yet is likely to slow down data extraction based on dates and times (see
below). It is thus recommnended to set this option to `FALSE` only when
subsequent data aggregation will **not** be based on dates or times.

## 5. Accessing Data

### 5.1 Origin-Destination Matrices

The primary function for extracting aggregate data from the `SQLite3` database
estabslihed with `store_bikedata()` is `bike_tripmat()`. The term 'trip
matrix' is used here and throughout the `bikedata` package to refer to an
origin-destination matrix. With the single mandatory argument naming the
database, this function returns a matrix of numbers of trips between all pairs
of stations.
```{r}
tm <- bike_tripmat (bikedb = 'bikedb')
head (tm)
```
Calling this function within specifying a city yet with a database containing
data from multiple cities will generate a message explaining that it is better
to extract trip matrices for particular cities. Absent city specificaiton, the
resultant trip matrix will include trips between bike stations in different
cities, for which there will obviously never be any recorded trips such that
for two cities, for example, maximally one half of the resultant matrix can
contain non-zero entries; for three cities, one ninth, and so on..

```{r}
tm <- bike_tripmat (bikedb = 'bikedb', city = 'ny')
head (tm)
```
Trip matrices can be returned either in square form (the default), with both
rows and columns named after the bicycle docking stations and matrix entries
tallying numbers of rides between each pair of stations, or in long form by
requesting `bike_tripmat (..., long = TRUE)`. The latter case will return a
`tibble` with the three columns of `station_station_id`, `end_station_id`, and
`number_trips`.

### 5.1.1. Temporal filtering of trip matrices

Trip matrices can also be extracted for particular dates, times, and days of
the week, through specifying one or more of the optional arguments:

1. `start_date`
2. `end_date`
3. `start_time`
4. `end_time`
5. `weekday`

Arguments in all cases can be specified in a range of possible formats as long
as they are unambiguous, and as long as 'larger' units precede 'smaller' units
(so, for example, months before days, hours before minutes). Acceptable formats
may be illustrated through specifying a list of arguments to be passed to
`bike_tripmat()`:
```{r}
args <- list (start_date = 16, end_time = 12, weekday = 1)
tm <- bike_tripmat (bikedb = 'bikedb', city = 'ny', args)
```
where a two-digit `start_date` (or `end_date`) is interpreted to represent a
year, while a one- or two-digit `_time` is interpreted to represent an hour,
with `end_time = 24` interpreted as `end_time = '23:59:59'`, while a `_time =
0` value is interpreted as `00:00:00'.  The following futher illustrate the
variety of acceptable formats,
```{r}
args <- list (start_date = "2016 May", end_time = "12:39", weekday = 2:6))
args <- list (end_date = 20160720, end_time = 123915, weekday = c ("mo", "we"))
args <- list (end_date = "2016-07-20"", end_time = "12:39:15", weekday = 2:6))
```
Arbitrary separators may be used in both `_date` and `_time` arguments where
these are specified as character strings. Numeric values must simply be in the
general largest-to-smallest-unit sequences explained above.

Weekdays may specified as characters, which must simply be unambiguous and (in
admission of currently inadequate internationalisation) corresspond to standard
English words. Minimal character specifications are thus `'so', 'm', 'tu', 'w',
'th', 'f', 'sa'`. The value of `weekday = 1` denotes Sunday, so `weekdays =
2:6` denote the traditional working days, Monday to Friday, while weekends may
be denoted with `weekdays = c ('sa', 'so')` or `weekdays = c (1, 7)`.


### 5.2. Demographic filtering of trip matrices

As described at the outset, the bicycle hire systems of several cities provide
additional demographic information including whether or not a cyclist is
registered with the system, and if so, their birth year, gender, and postal
(zip) code. Note that the provision of such information is voluntary, and that
no proviers can or do guarantee the accuracy of their data.

Those systems which provide demographic information are listed with the
function `bike_demographic_data()`, which also lists the nominal kinds of
demographhic data provided by the different systems. Data can then be filtered
by demographic parameters with additional optional arguments to
`bike_tripmat()` of,

1. `registered` (`TRUE/FALSE`, `'yes'/'no'`, 0/1)
2. `birth_year` (as one or more four-digit numbers or character strings)
3. `gender` ('m/f/.', 'male/female/other')
4. `post_code` (as five-digit number or character string)

Many systems allow users to specify alternative genders, and any values not
beginning with either `'m'` or `'f'` (case-insensitive) are interpreted as
requests for alternative genders. Because there is no systematic way to specify
alternative genders, additional filtering beyond these three classes of gender
is currently not possible.  Note further that, although the only systems to
date which provide postal addresses are from the U.S., this parameter is not
called `zip` to avoid potential association with the `.zip`-format files
generally provided by the hire bicycle systems and accessed by `bikedata`.

It is of course possible to combine all of these optional parameters in a
single query. For example,
```{r, eval=FALSE}
tm <- bike_tripmat (bikedb = 'bikedb', city = 'ny', start_date = 2016,
        start_time = 9, end_time = 24, weekday = 2:6, gender = 'xx', 
        birth_year = 1900:1950)
```
The value of `gender = 'xx'` will be interpreted to request data from all
members with nominal alternative genders.  As demographic data are only given
for registered users, the `registered` parameter is redudant in this query.
Note further than many systems offer a range of potential birth years starting
with 1900, and there are consequently a significant number of cyclists who
declare this as their birth year.



### 5.3. Summary Statistics

`bikedata` provides a number of helper functions for extracting summary
statistics from the `SQLite3` database. The function `bike_summary_stats
(bikedb)` generates a table providing a quick overview.

```{r}
bike_summary_stats ('bikedb')
# Total of --- trips from 5 cities
# 
# city  |   first trip  |   last trip   | number of trips
# ------|---------------|---------------|-----------------
# 
#  ...
```
Additional helper functions which provide individual components from this
summary data include:
```{r}
bike_num_trips (bikedb = 'bikedb', city = 'ny')
bike_date_range (bikedb = 'bikedb', city = 'ny')
```
Data on the bicycle stations can also be extracted as follows:
```{r, eval=FALSE}
bike_stations (bikedb = 'bikedb)
```
Specifying an additional `city` parameter will return information only on bike
stations for the nominated city.


## 6. Direct database access


Although the `bikedata` package aims to circumvent any need to access the
database directly, through providing ready extraction of trip data for most
analytical needs, direct access may be achieved either using the convenient
`dplyr` functions, or the more powerful functionality provided by the `RSQLite`
package.

```{r}
# demo list of tables and contents of both trips and stations tables
```

## 7. Visualisation of bicycle trips

The `bikedata` package does not provide any functions enabling visualisation of
aggregate trip data, both because of the primary focus on enabling access and
aggregation in the simplest practicable way, and because of the myriad
different ways users of the package are likely to want to visualise the data.
This section therefore relies on other packages to illustrate some of the ways
in which trip matrices may be visualised.

The simplest spatial visualisation involves connecting the geographical
coordinates of stations with straight lines, with numbers of trips represented
by some characteristics of the lines connecting pairs of stations, such as
thickness or colours.  This can be achieved with the following code, which also
illustrates that it is generally more useful for visualisation purposes to
extract trip matrices in long rather than square form.
```{r}
stns <- bike_stations (bikedb = 'bikedb', city = 'nyc')
ntrips <- bike_tripmat (bikedb = 'bikedb', city = 'nyc', long = TRUE)
x1 <- stns$longitude [match (stns$longitude, ntrips$start_station)]
y1 <- stns$latitude [match (stns$longitude, ntrips$start_station)]
x2 <- stns$longitude [match (stns$longitude, ntrips$end_station)]
y2 <- stns$latitude [match (stns$longitude, ntrips$end_station)]
plot (stations$longitude, stations$latitude)
lines (cbind (x1, y1), cbind (x2, y2), 
        lwd = ntrips$num_trips * 10 / max (ntrips$num_trips))
```
