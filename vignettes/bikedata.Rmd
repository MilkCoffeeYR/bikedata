---
title: "1. bikedata"
author: 
  - "Mark Padgham"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        theme: flatly
vignette: >
  %\VignetteIndexEntry{1. osmdata}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 1. Introduction

`bikedata` is an R package for downloading and aggregating data from 
public bicycle hire, or bike share, systems. Although there are very many
public bicycle hire systems in the world [see this wikipedia
list](https://en.wikipedia.org/wiki/List_of_bicycle-sharing_systems), very few
openly publish data on system usage. The `bikedata` package aims to enable
ready importing of data from all systems which provide data, and will be
expanded on an ongoing basis as more systems publish open data. Cities and names
of associated public bicycle Systems currently included, along with numbers of
bikes and of docking stations, are:

City | Hire Bicycle System | Number of Bicycles | Number of Docking Stations
--- | --- | --- | ---
London, U.K. | [Santander Cycles](https://tfl.gov.uk/modes/cycling/santander-cycles) | 13,600 | 839
New York City NY, U.S.A. | [citibike](https://www.citibikenyc.com/) | 7,000 | 458
Chicago IL, U.S.A. | [Divvy](https://www.divvybikes.com/) | 5,837 | 576
Washingon DC, U.S.A. | [Capital BikeShare](https://www.capitalbikeshare.com/) | 4,457 | 406
Boston MA, U.S.A. | [Hubway](https://www.thehubway.com/) | 1,461 | 158
Los Angeles CA, U.S.A. | [Metro](https://bikeshare.metro.net/) | 1,000 | 65

Cities with extensively developed systems and cultures of public hire bicycles,
yet which do not provide (publicly available) data include:

City | Number of Bicycles | Number of Docking Stations
--- | --- | ---
Hangzhou, China | 78,000 | 2,965
Paris, France | 14,500 | 1,229
Barcelona, Spain | 6,000 | 424

The development version of the `bikedata` R package can be installed with the
`devtools` package using the following command:
```{r install, eval = FALSE}
devtools::install_github('mpadge/bikedata')
```

```{r, echo = FALSE, message = FALSE, results = 'hide'}
devtools::load_all('..', export_all = FALSE)
```

Once installed, it can be loaded in the usual way:

```{r, eval = FALSE}
library(bikedata)
```

## 2. Main Functions

All of the public bicycle hire systems in the first of the above lists record
and disseminate individual trip data, minimally including the times and places at
which every trip starts and ends. Some systems provide additional anonymised
individual data, typically including whether or not a user is registered with
the system and if so, additional data including age, gender, and residential
postal code.

These data on individual trips can be imported into `R` with the primary
function `store_bikedata()`, which minimally requires specifying a city from the
above list and the name of a database in which the data will be stored.
```{r, eval = FALSE}
store_bikedata (bikedb = 'bikedb', city = 'la')
```
This function call will download all available data from the Metro system of Los
Angeles, CA and store it in an `SQLite3` database named `bikedb`. Both the
downloaded data and the `SQLite3` database are stored in the temporary
directory of the current `R` session. The downloaded data are deleted after
having been loaded into the `SQLite3` database, and the database itself is
deleted on termination of the `R` session.  (All of these options may be
overridden as described below.)

Successive calls to `store_bikedata()` will append additional data to the same
database. For example, the following line will append all data from Chicago's
Divvy bike system from the year 2017 to the database created with the first
call above. 
```{r, eval = FALSE}
store_bikedata (bikedb = 'bikedb', city = 'divvy', dates = 2017)
```
The function again returns the number of trips *added* to the database, which
is now less than the total number of trips stored of:
```{r, eval=FALSE}
bike_total_trips (bikedb = 'bikedb')
```
For consistency and to avoid potential confusion of function names, most
functions in the `bikedata` package begin with the prefix `bike_`.

Finally, the main way that individual trip data are aggregated in the
`bikedata` package is as trip matrices containing aggregate numbers of trips
between all pairs of stations for a given city. Trip matrices can be extracted
with the call, 
```{r, eval = FALSE}
tm <- bike_tripmat (bikedb = 'bikedb', city = 'la')
```
Details of the docking stations associated with these trip matrices can be
obtained with
```{r, eval=FALSE}
bike_stations (bikedb = 'bikedb')
bike_stations (bikedb = 'bikedb', city = 'la')
```

The latter call reveals that Los Angeles has 65 docking stations, and thus the
trip matrix has this same number of rows and columns,
```{r, eval = FALSE}
dim (dm); sum (tm)
```
between which a total of XXX individual trips up to March 2017.

The remainder of this vignette details these three distinct functional aspects
- downloading, storage, and extraction of data.

## 3. Downloading Data

Data may be automatically downloaded using the `store_bikedata()` function
demonstrated above, yet this function always deletes the downloaded files once
the data has been loaded into the `SQLite3` database. The `dl_bikedata()`
function enables  enduring copies of the raw data files to be downloaded to a
specified location.  The function accepts only one additional argument
(`dates`) specifying ranges of dates for which data should be downloaded. The
format of the `dates` argument is quite flexible so that,
```{r, eval = FALSE}
dl_bikedata (city = 'dc', dates = 16)
```
will download data from Washington DC's Capital Bikeshare system for all 12
months of the year 2016, while,
```{r, eval = FALSE}
dl_bikedata (city = 'ny', dates = 201604:201608)
```
will download New York City data from April to August (inclusively) for that
year. Dates can also be entered as character strings, with the following calls
producing results equivalent to the preceding call, 
```{r, eval = FALSE}
dl_bikedata (city = 'ny', dates = '2016/04:2016/08')
dl_bikedata (city = 'new york', dates = '201604:201608')
dl_bikedata (city = 'n.y.c.', dates = '2016-04:2016-08')
dl_bikedata (city = 'new', dates = c (201604, 201605, 201606, 201607, 201608))
dl_bikedata (city = 'ci', dates = 201600 + 4:8)
```
The arguments `city = 'new'` and `city = 'ci'` in the final call are sufficient
to uniquely identify New York City's citibike system.

As mentioned, data from the Santander Cycles Scheme of London, U.K.  require
registration with [Transport for London](tfl.gov.uk). Registration enables
access to an `OAuth` key which must additionally be passed to both the
`dl_bikedata()` and `store_bikedta()` functions to access these data.
```{r, eval=FALSE}
store_bikedata (city = 'lo', bikedb = 'bikedb')
```
If files have been previously downloaded to a nominated directory, then calling
the `dl_bikedata()` function will only download those data files that do not
already exist. This function may thus be used to periodically refresh the
contents of a nominated directory as new data files become available.

## 4. Storing Data

As mentioned above, individual trip data are stored in a single `SQLite3`
database, created by default in the temporary directory of the current `R`
session. Specifying a path for the `bikedb` argument in the `store_bikedata()`
function will create a database that will remain in that location until
explicitly deleted. 

The nominated database is created if it does not already exist, otherwise
additional data are appended to the existing database. As with the
`dl_bikedata()` function demonstrated above, a `dates` argument can also be
passed to `store_bikedata()` to download data within a defined range of dates.

`bikedata` is explicitly designed *not* to permit automatic downloading of all
data in a single call, lest an innocent exploratory usage inadvertently
generate a database several gigabytes in size.  Loading data from other cities
accordingly requires repeated calls to `store_bikedata()`. The entirety of
currently available data can be loaded with the following lines:
```{r, eval = FALSE}
for (ci in bike_available_cities ())
    ntrips <- store_bikedata (city = ci, bikedb = 'bikedb')
```


### 4.1 Database Indexes

The `store_bikedata()` function also has a default option to create indexes for
more efficient data extraction. Indexes are always created for cities, with the
`create_index = TRUE` option creating additional indexes for dates and times.
Setting this parameter to `FALSE` will enable faster initial storage of data,
yet is likely to lead to slower aggregation of data based on dates and times
(see below). It is thus recommended to set this option to `FALSE` only when
subsequent data aggregation will **not** be based on dates or times.

## 5. Accessing Aggregate Data

### 5.1 Origin-Destination Matrices

The primary function for extracting aggregate data from the `SQLite3` database
established with `store_bikedata()` is `bike_tripmat()`. With the single
mandatory argument naming the database, this function returns a matrix of
numbers of trips between all pairs of stations.  Trip matrices can be returned
either in square form (the default), with both rows and columns named after the
bicycle docking stations and matrix entries tallying numbers of rides between
each pair of stations, or in long form by requesting `bike_tripmat (..., long =
TRUE)`. The latter case will return a `tibble` with the three columns of
`station_station_id`, `end_station_id`, and `number_trips`.
```{r, eval=FALSE}
tm <- bike_tripmat (bikedb = 'bikedb', city = 'la')
head (tm)
```
It is possible to extract a square matrix aggregating trips between all
stations from all cities within the database,
```{r, eval=FALSE}
tm <- bike_tripmat (bikedb = 'bikedb', long = FALSE)
```
yet doing so prompts a message explaining that it is better to extract trip
matrices for particular cities. Absent city specification, the resultant trip
matrix will include trips between bike stations in different cities, for which
there will obviously never be any recorded trips such that for two cities, for
example, maximally one half of the resultant matrix can contain non-zero
entries; for three cities, one ninth, and so on. In contrast, single long-form
trip matrices may be aggregated for all cities without generating such a
message, because in this case the matrix includes only those pairs of stations
with one or more trips between them., 
```{r, eval=FALSE}
tm <- bike_tripmat (bikedb = 'bikedb', long = TRUE)
```


### 5.1.1. Temporal filtering of trip matrices

Trip matrices can also be extracted for particular dates, times, and days of
the week, through specifying one or more of the optional arguments:

1. `start_date`
2. `end_date`
3. `start_time`
4. `end_time`
5. `weekday`

Arguments in all cases can be specified in a range of possible formats as long
as they are unambiguous, and as long as 'larger' units precede 'smaller' units
(so, for example, months before days, hours before minutes). Acceptable formats
may be illustrated through specifying a list of arguments to be passed to
`bike_tripmat()`:
```{r, eval=FALSE}
args <- list (start_date = 16, end_time = 12, weekday = 1)
tm <- bike_tripmat (bikedb = 'bikedb', city = 'ny', args)
```
where a two-digit `start_date` (or `end_date`) is interpreted to represent a
year, while a one- or two-digit `_time` is interpreted to represent an hour,
with `end_time = 24` interpreted as `end_time = '23:59:59'`, while a 
`_time = 0` value is interpreted as `00:00:00`.  The following further illustrate
the variety of acceptable formats,
```{r, eval=FALSE}
args <- list (start_date = '2016 May', end_time = '12:39', weekday = 2:6)
args <- list (end_date = 20160720, end_time = 123915, weekday = c ('mo', 'we'))
args <- list (end_date = '2016-07-20', end_time = '12:39:15', weekday = 2:6)
```
Arbitrary separators may be used in both `_date` and `_time` arguments where
these are specified as character strings. Numeric values must simply be in the
general largest-to-smallest-unit sequences explained above.

Weekdays may specified as characters, which must simply be unambiguous and (in
admission of currently inadequate internationalisation) correspond to standard
English words. Minimal character specifications are thus `'so', 'm', 'tu', 'w',
'th', 'f', 'sa'`. The value of `weekday = 1` denotes Sunday, so `weekdays =
2:6` denote the traditional working days, Monday to Friday, while weekends may
be denoted with `weekdays = c ('sa', 'so')` or `weekdays = c (1, 7)`.


### 5.2. Standarding trip counts by durations of operation

Most bicycle hire systems have progressively expanded over time through ongoing
addition of new docking stations. Total numbers of counts within a trip matrix
will thus be generally less for more recently installed stations, and more for
older stations. The `bike_tripmat()` function has an option to allow trip
matrices to be standardised for durations of station operation, so that numbers
of trips between any pair of stations reflect what they would be if all
stations had been in operation for the same duration.

Total numbers of trips to and from each station are simply linearly scaled
according to the total duration of operation, and the final matrix again
standardised to have the same total number of trips as the original matrix.
This has two immediate consequences:

1. Trip numbers will not necessarily be integer values, but are rounded for
sanity purposes to three digits, corresponding to the maximal likely precision
attainable for daily differences in operating durations;
2. Trip numbers will generally **not** equal actual observed numbers. Counts
for the longest operating durations will be lower than actually recorded, while
counts for more recent stations will be greater than observed values.


### 5.4. Demographic filtering of trip matrices

As described at the outset, the bicycle hire systems of several cities provide
additional demographic information including whether or not cyclists are
registered with the system, and if so, additional information including birth
years, genders, and postal (zip) codes. Note that the provision of such
information is voluntary, and that no providers can or do guarantee the accuracy
of their data.

Those systems which provide demographic information are listed with the
function `bike_demographic_data()`, which also lists the nominal kinds of
demographic data provided by the different systems. Data can then be filtered
by demographic parameters with additional optional arguments to
`bike_tripmat()` of,

1. `registered` (`TRUE/FALSE`, `'yes'/'no'`, 0/1)
2. `birth_year` (as one or more four-digit numbers or character strings)
3. `gender` ('m/f/.', 'male/female/other')
4. `post_code` (as five-digit number or character string)

Many systems allow users to specify alternative genders, and any values not
beginning with either `'m'` or `'f'` (case-insensitive) are interpreted as
requests for alternative genders. Because there is no systematic way to specify
alternative genders, additional filtering beyond these three classes of gender
is currently not possible.  Note further that, although the only systems to
date which provide postal addresses are from the U.S., this parameter is not
called `zip` to avoid potential association with the `.zip`-format files
generally provided by the hire bicycle systems and accessed by `bikedata`.

It is of course possible to combine all of these optional parameters in a
single query. For example,
```{r, eval=FALSE}
tm <- bike_tripmat (bikedb = 'bikedb', city = 'ny', start_date = 2016,
        start_time = 9, end_time = 24, weekday = 2:6, gender = 'xx', 
        birth_year = 1900:1950)
```
The value of `gender = 'xx'` will be interpreted to request data from all
members with nominal alternative genders.  As demographic data are only given
for registered users, the `registered` parameter is redundant in this query.
Note further than many systems offer a range of potential birth years starting
with 1900, and there are consequently a significant number of cyclists who
declare this as their birth year.



### 5.5. Summary Statistics

`bikedata` provides a number of helper functions for extracting summary
statistics from the `SQLite3` database. The function `bike_summary_stats
(bikedb)` generates a table providing a quick overview.

```{r, eval=FALSE}
bike_summary_stats ('bikedb')
# Total of --- trips from 5 cities
# 
# city  |   first trip  |   last trip   | number of trips
# ------|---------------|---------------|-----------------
# 
#  ...
```
Additional helper functions which provide individual components from this
summary data include:
```{r, eval=FALSE}
bike_num_trips (bikedb = 'bikedb', city = 'ny')
bike_date_range (bikedb = 'bikedb', city = 'ny')
```
Data on the bicycle stations can also be extracted as follows:
```{r, eval=FALSE}
bike_stations (bikedb = 'bikedb)
```
Specifying an additional `city` parameter will return information only on bike
stations for the nominated city.


### 5.6 Analytical Statistics

The `bikedata` package currently provides only one mode of analysing aggregate
trip data, through calculating covariances or corresponding correlation
coefficients (hereafter, C-C coefficients) between all pairs of stations, using
the respective functions `bike_cov ()` and `bike_cor ()`. Both functions accept
the single argument of a trip matrix returned from the `bike_tripmat ()`
function (in either long or square form), and return matrices of C-C
coefficients in the same (long or square) form.

Although other packages offer ready ability to calculate similar matrix
C-C coefficients, trip matrices have two uncommon aspects:

1. They are asymmetrical (`tripmat [a, b]` will generally *not* equal 
    `tripmat [b, a]`); and
2. There are many circumstances under which values of zero should be excluded
    from calculations.

The asymmetrical nature of trip matrices means that C-C matrices can also be
represented in correspondingly asymmetric form, so that the lower diagonal half
of the matrices contain C-C coefficients between trips *from* a given pair of
stations to all other stations in the system, while the upper diagonal half
contains corresponding coefficients calculated between trips *to* a given pair
of stations. The lower diagonal half of a square matrix, `c_mat`, containing
C-C coefficients between all pairs of trips *from* each station, corresponds
to all data, `c_mat [a, b]`, for which `a<b`, while the upper diagonal half
containing C-C coefficients between all trips *to* each pair of stations
corresponds to all entries, `c_mat [a, b]`, for which `a>b`.  Long-form
matrices of C-C coefficients contain four columns: the first two naming a pair
of stations, and a third and fourth respectively holding C-C coefficients for
trips *from* and *to* that pair of stations to all other stations in the
system.

The ability to include or exclude zeros is also important, as trip matrices may
often contain many zero entries. For some analytic purposes, it may be
appropriate to include these zero entires as genuine values of zero, while for
other purposes they may be more appropriately considered as cases of missing
data that ought be excluded from analysis. The parameter `exclude_zeros`
enables C-C coefficients to be calculated for both cases.

The following code demonstrates the general property that inclusion of zeros as
genuine data generally yields higher C-C coefficients, because comparisons of
numbers of trips between a series of stations will be quantitatively more
similar wheen series contain coincident zeros.
```{r, eval=FALSE}
store_bikedata (bikedb = 'bikedb', city = 'ny', dates = 2016)
tm <- tripmat (bikedb = 'bikedb', start_time = 6, end_time = 8)
mean (bike_cov (tripmat, exclude_zeros = FALSE))
mean (bike_cov (tripmat, exclude_zeros = TRUE))
mean (bike_cor (tripmat, exclude_zeros = FALSE))
mean (bike_cor (tripmat, exclude_zeros = TRUE))
```


## 6. Direct database access


Although the `bikedata` package aims to circumvent any need to access the
database directly, through providing ready extraction of trip data for most
analytical needs, direct access may be achieved either using the convenient
`dplyr` functions, or the more powerful functionality provided by the `RSQLite`
package.

```{r, eval=FALSE}
# demo list of tables and contents of both trips and stations tables
```

## 7. Visualisation of bicycle trips

The `bikedata` package does not provide any functions enabling visualisation of
aggregate trip data, both because of the primary focus on enabling access and
aggregation in the simplest practicable way, and because of the myriad
different ways users of the package are likely to want to visualise the data.
This section therefore relies on other packages to illustrate some of the ways
in which trip matrices may be visualised.

The simplest spatial visualisation involves connecting the geographical
coordinates of stations with straight lines, with numbers of trips represented
by some characteristics of the lines connecting pairs of stations, such as
thickness or colours.  This can be achieved with the following code, which also
illustrates that it is generally more useful for visualisation purposes to
extract trip matrices in long rather than square form.
```{r, eval=FALSE}
stns <- bike_stations (bikedb = 'bikedb', city = 'nyc')
ntrips <- bike_tripmat (bikedb = 'bikedb', city = 'nyc', long = TRUE)
x1 <- stns$longitude [match (stns$longitude, ntrips$start_station)]
y1 <- stns$latitude [match (stns$longitude, ntrips$start_station)]
x2 <- stns$longitude [match (stns$longitude, ntrips$end_station)]
y2 <- stns$latitude [match (stns$longitude, ntrips$end_station)]
plot (stations$longitude, stations$latitude)
lines (cbind (x1, y1), cbind (x2, y2), 
        lwd = ntrips$num_trips * 10 / max (ntrips$num_trips))
```
